# 作用域链
作用域链
在找变量的时候，先从当前上下文的变量对象中查找，如果没有找到 ，就会从词法层面上的腹肌执行上下文的变量对象中查找，一直找到全局上下文的变量对象（就是全局变量）。这样的由多个执行上下文的变量对象构成的链表就叫作用域链。

## 函数创建
关于函数的作用域在函数定义的时候决定，是因为函数有一个内部属性 **[[scope]]**,当函数创建的时候，会保存所有的父变量对象到其中，可以理解[[scope]]就是所有父变量对象的层级链，但是它不代表完整的作用域链!
```js
function foo(){
    function bar(){

    }
}

foo.[[scope]] = [
    globalContect.VO
];
bar.[[scope]] = [
    fooContext.AO,
    globalContext.VO
];
```
## 函数激活
当函数被激活 进入函数上下文，创建VO/AO后，会将活动对象添加大哦作用链的前端。
这时候执行上下文的作用域链 命名为Scope：
Scope = [AO].concat([[scope]])


问题：
checkscope函数被创建时，保存到[[scope]]的作用域链和checkscope执行前的准备工作中，复制函数[[scope]]属性创建的作用域链有什么不同么？为什么会有两个作用域链？
答：checkscope函数创建的时候 保存词法所生成的作用域链 checkscope执行的时候，会复制这个作用域链，作为自己作用域链的初始化，然后根据环境生成变量对象，然后将这个变量对象，添加到这个复制的作用域链，这才完整的构成了自己的作用域链。