html的内容由标记（标签）和文本组成。浏览器根据不同的语义老展示HTML内容。
css层叠样式表，由选择器和属性组成。
JavaScript使用它可以使网页的内容动起来。
渲染流水线：

按照渲染时间，流水线可分为几个子阶段：构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。
子阶段的输入内容、处理过程、输出内容？

构建DOM树：
因为浏览器无法直接理解和使用HTML，所以要将HTML转换为浏览能够理解的结构---DOM树


可以在控制台，输入document+回车看到DOM树结构。
输入内容：一个非常简单的html文件，然后由html解析器解析，最终输出树状结构的DOM。
DOM和HTML的内容几乎使一样的，但是和HTML不同的是，DOM是保存在内存中树状结构，可以通过JavaScript来查询或者修改内容。
DOM树已经生成，但是DOM节点的样式依然不知道，需要样式计算。

样式计算
为了计算DOM节点的每一个元素的具体样式。分为三步。
	1. 把css转换为浏览器能够理解的结构。
	
	
浏览器无法直接理解这些纯文本的css样式，所以要将渲染引擎接收到的css文本时，会执行一个转换操作，将css文本转换为浏览器可以理解的结构---styleSheets
控制台输入document.styleSheets.
重点：渲染引擎会把获取到的css文本全部转换为styleSheets结构中的数据，并且该结构同时具备查询和修改功能，为后面的样式操作提供基础。
	2. 转化样式表中的属性值，使其标准化。
属性标准化：像2em、blue这样的类型不容易被渲染引擎理解，需要把所有值转换为渲染引擎容易理解的、标准化的计算值，这就是属性值标准化。



	3. 计算出DOM树中每一个节点的具体样式
涉及css的继承规则和层叠规则。
	- css继承 就是每一个DOM节点都包含有父节点的样式。
特别提一下：在开发者工具查看css，最右边的是样式来源，是来源于样式文件还是UserAgent样式表。（UserAgent是浏览器提供的一组默认样式）
	- 层叠规则。层叠是css的一个基本特征，它定义了如何合并来自多个源的属性值的算法。处于css核心地位。

布局阶段
创建布局树和布局计算。计算出DOM树中可见元素的几何位置。
	1. 创建布局树
   - 遍历DOM树中的所有可见节点，并把这些节点加到布局树中。
   - 不可见的节点会被布局树忽略掉。比如head的内容，含有display ：none的元素。
	2. 布局计算
	
总结：
	1. 浏览器不能直接理解HTML数据，第一要将其转换为浏览器能够理解的DOM树结构
	2. 生成DOM树之后，还需要根据css样式表，来计算出DOM树所有节点的样式
	3. 最后计算DOM元素的布局信息，将其保存在布局树之中

思考：如果下载的css文件堵塞了，会堵塞dom树的合成吗？会堵塞页面的展示吗？

分层
因为页面中有很多复杂的效果，如3D变换、页面滚动等。渲染引擎要为这些特定的节点生成专用的图层，并生成一颗对应的图层树。
浏览器页面实际分为很多图层，这些图层叠加后合成最终页面。

	

屏幕剪辑的捕获时间: 2020/6/14 15:45

并不是布局树的每一个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。
创建新图层的要求是什么？
第一点拥有层叠上下文属性的元素会被提升为单独的一层。
层叠上下文：HTML元素按照自身属性的优先级分布在z轴。
第二点需要裁剪的地方也会被创建为图层。
比如div为200*200，里面的文字内容会超出div，这个时候就要裁剪。渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。

图层绘制
渲染引擎会把一个图层拆分成很小的绘制指令，把这些执行按照顺序组成一个待绘制列表。这个表里的指令很简单，就是让其执行一个简单的绘制操作，比如红色的框。绘制一个元素通常要好几条绘制指令。所以在图层绘制阶段，输出的内容就是这些待绘制列表。

栅格化（rester）操作
绘制列表是用来记录绘制顺序和绘制指令的列表。绘制操作还是由渲染引擎的合成线程来完成。
视口：屏幕上页面的可见区域就叫视口。
场景：在一个很大的页面，滚动条要滚动好久才能到底部，但是通过视口，用户只能看到一小部分，在这种情况下绘制出所有的图层内容，就会产生太大的开销，而且没必要。------>合成线程会将图层划分为图块，图块大小一般为256*256 或者512*512



合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作的由栅格化来执行。栅格化是指将图块转换为位图。
图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。
通常 栅格化都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。

合成与显示
一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令---“DrawQuad” ，然后把这个命令提交格浏览器进程。
浏览器有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后将内存显示到屏幕上。
经过一系列的阶段 编写好HTML 、css 。JavaScript等文件 经过浏览器就会显示出漂亮的页面了。

总结：
	1. 渲染进程将HTML内容转换为能够读懂的DOM树结构
	2. 渲染引擎将css样式表转化位浏览器可以理解的styleSheets 计算初DOM节点的样式
	3. 创建布局树 并计算出元素的布局信息
	4. 对布局树进行分层 并生成分层树
	5. 为每一个图层生成绘制列表，并将其提交到合成线程中
	6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换为位图
	7. 合成线程发送绘制图块DrawQuad给浏览器进程
	8. 浏览器进程根据DrawQuad消息生成页面，并显示到显示器中。

相关概念：
	1. 更新了元素的几何属性（重排）
通过JavaScript或者css修改元素的几何位置属性（比如改变原色的宽度、高度），那么浏览器会触发重新布局，解析之后的一系列子阶段 ，这个过程叫做重排。重排需要更新完整的渲染流水线，所以开销也是最大的。
	2. 更新元素的绘制属性（重绘）
如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变化，所以就直接进入到绘制阶段，然后执行之后的一系列子阶段 这个过程叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率也会比重排操作高一些。
	3. 直接合成阶段
如果更改一个既不要布局也不要绘制的属性，渲染引起将跳过布局和绘制，只执行后续的合成操作，这个过程叫合成。



比如直接使用css的transform来实现动画效果，这样可以避免重排的重绘阶段，直接在非主流线程上执行合成动画操作。
在非主流线程上合成 没有占用主线程的资源。相对于重排和重绘 合成能大大提升绘制效率。

思考：
	1. 为什么重绘重拍能优化web性能？由哪些具体的实践方法能减少重绘重排呢？
减少重绘重排相当于减少了渲染进程的主线程和非主线的很多计算和操作，能够加快web的操作。
	- 使用class操作样式，而不是频繁操作style
	- 避免使用table布局
	- 批量dom操作，例如createDocumentFragment 或者使用框架 例如react
	- Debounce window resize事件
	- 对dom属性的读写要分离
	- will-change：transform做优化
	2. 渲染进程中的帧？
电影的帧速是24，就是每一秒切换24幅画面。关于页面，因为大多数设备的屏幕刷新率为60次/秒。因此页面中如果有一个画面/渐变效果/用户滚动页面，那么浏览器渲染动画的频率至少要和刷新频率保持一致，就是每秒更新60次，平均下来就是每一帧的预算为1/60毫秒，如果超过16毫秒 帧频下降，并且会出现画面抖动的现象 通常被称为卡顿，影响用户体验。
	
